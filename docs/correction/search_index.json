[["index.html", "Tutorial: Dynamic data visualization with R Presentation", " Tutorial: Dynamic data visualization with R Laurent Rouvière 2022-11-28 Presentation This tutorial provides some R tools for data visualization. You can find materials (slides) associated with this tutotial as well as datasets at https://lrouviere.github.io/page_perso/visualisationR.html#smart-data; tutorial without correction at https://lrouviere.github.io/TUTO_DATAVIZ; tutorial with corrections at https://lrouviere.github.io/TUTO_DATAVIZ/correction. I strongly encourage to use mozilla firefox to read this tutorial. Basics on R and computer programming are necessary. The tutorial is divided into tree parts : Visualization with ggplot2: presentation of the ggplot2 grammar; Mapping with R: how to build map with ggmap, sf and leaflet ; Dynamic visualization: some tools to make interactive visusalization (rAmCharts, plotly), dasboard and web applications (shiny). "],["ggplot2.html", "Chapter 1 Data visualization with ggplot2 1.1 Conventional Graphical Functions 1.2 Ggplot2 grammar 1.3 Complements 1.4 Some exercises", " Chapter 1 Data visualization with ggplot2 Graphs are often the starting point for statistical analysis. One of the main advantages of R is how easy it is for the user to create many different kinds of graphs. We begin this chapter by studying conventional graphs, followed by an examination of some more complex representations. This final (and main) part uses the ggplot2 package. 1.1 Conventional Graphical Functions To begin with, it may be interesting to examine few examples of graphical representations which can be constructed with R. We use the demo function: demo(graphics) 1.1.1 The plot function The plot function is a generic function used to represent all kinds of data. We can use this function for representing a scatterplot for a variable y according to another variable x. For example, to represent the graph of the function \\(x\\mapsto \\sin(2\\pi x)\\) on \\([0,1]\\), at regular steps we use the following commands: x &lt;- seq(-2*pi,2*pi,by=0.05) y &lt;- sin(x) plot(x,y) #points (par défaut) plot(x,y,type=&quot;l&quot;) #représentation sous forme de ligne We provide examples of representations for quantitative and qualitative variables. We use the data file ozone.txt: ozone &lt;- read.table(&quot;data/ozone.txt&quot;) summary(ozone) maxO3 T9 T12 Min. : 42.00 Min. :11.30 Min. :14.00 1st Qu.: 70.75 1st Qu.:16.20 1st Qu.:18.60 Median : 81.50 Median :17.80 Median :20.55 Mean : 90.30 Mean :18.36 Mean :21.53 3rd Qu.:106.00 3rd Qu.:19.93 3rd Qu.:23.55 Max. :166.00 Max. :27.00 Max. :33.50 T15 Ne9 Ne12 Min. :14.90 Min. :0.000 Min. :0.000 1st Qu.:19.27 1st Qu.:3.000 1st Qu.:4.000 Median :22.05 Median :6.000 Median :5.000 Mean :22.63 Mean :4.929 Mean :5.018 3rd Qu.:25.40 3rd Qu.:7.000 3rd Qu.:7.000 Max. :35.50 Max. :8.000 Max. :8.000 Ne15 Vx9 Vx12 Min. :0.00 Min. :-7.8785 Min. :-7.878 1st Qu.:3.00 1st Qu.:-3.2765 1st Qu.:-3.565 Median :5.00 Median :-0.8660 Median :-1.879 Mean :4.83 Mean :-1.2143 Mean :-1.611 3rd Qu.:7.00 3rd Qu.: 0.6946 3rd Qu.: 0.000 Max. :8.00 Max. : 5.1962 Max. : 6.578 Vx15 maxO3v vent Min. :-9.000 Min. : 42.00 Length:112 1st Qu.:-3.939 1st Qu.: 71.00 Class :character Median :-1.550 Median : 82.50 Mode :character Mean :-1.691 Mean : 90.57 3rd Qu.: 0.000 3rd Qu.:106.00 Max. : 5.000 Max. :166.00 pluie Length:112 Class :character Mode :character Let us start by representing two quantitative variables: maximum ozone concentrations maxO3 in term of temperatures T12: plot(ozone[,&quot;T12&quot;],ozone[,&quot;maxO3&quot;]) As the two variables are contained and named within the same table, a simpler syntax can be used, which automatically inserts the variables as labels for the axes: plot(maxO3~T12,data=ozone) We can also use (more complicated and less interesting) plot(ozone[,&quot;T12&quot;],ozone[,&quot;maxO3&quot;],xlab=&quot;T12&quot;,ylab=&quot;maxO3&quot;) We have specific functions for each kind of charts, for instance hist(ozone$maxO3,main=&quot;Histogram&quot;) barplot(table(ozone$vent)/nrow(ozone),col=&quot;blue&quot;) boxplot(maxO3~vent,data=ozone) 1.1.2 Interactive graphs with rAmCharts We can use this package to obtain dynamic graphs. It is easy, we just have to use the prefix am before the name of the function: library(rAmCharts) amHist(ozone$maxO3) amPlot(ozone,col=c(\"T9\",\"T12\")) amBoxplot(maxO3~vent,data=ozone) 1.1.3 Some exercises Exercise 1.1 (First chart) Draw the sine function between 0 and \\(2\\pi\\). x &lt;- seq(0,2*pi,length=1000) plot(x,sin(x),type=&quot;l&quot;) Add the following title: Plot of the sine function, you can use the function title. title(&quot;Plot of the sine function&quot;) Exercise 1.2 (Gaussian density distribution) Draw the pdf (probability distribution function) of the standard Gaussian distribution between \\(-4\\) and 4 (use dnorm). x &lt;- seq(-4,4,by=0.01) plot(x,dnorm(x),type=&quot;l&quot;) Add a vertical dashed line of equation \\(x=0\\) (use abline). abline(v=0,lty=2) On the same graph, draw Student’s \\(t\\)-distribution to 5 and 30 degrees of freedom (use dt). Use the lines function and a different colour for each density. lines(x,dt(x,5),col=2) lines(x,dt(x,30),col=3) Add a legend at the top left to differentiate between each distribution (use legend). legend(&quot;topleft&quot;,legend=c(&quot;Normal&quot;,&quot;Student(5)&quot;,&quot;Student(30)&quot;), col=1:3,lty=1) Exercise 1.3 (Drawing sunspots) Read the file taches_solaires.csv series which details, data by data, the relative number of sunspots. spots &lt;- read.table(&quot;data/taches_solaires.csv&quot;,sep=&quot;;&quot;,header=TRUE,dec=&quot;,&quot;) Using the cut_interval function from the tidyverse package, create a qualitative variable which separates the dates into 8 intervals. We call period this variable. library(tidyverse) period &lt;- cut_interval(spots$annee,n=8) Use the following levels for period mycolors &lt;- c(&quot;yellow&quot;, &quot;magenta&quot;, &quot;orange&quot;, &quot;cyan&quot;, &quot;grey&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) levels(period) &lt;- mycolors Explain the output of coordx &lt;- seq(along=spots[,1]) We create a sequence from 1 to the length of spots[,1]. Visualize the sunspot series with a diffrect color for the 8 periods. plot(coordx,spots[,1],xlab=&quot;Temps&quot;,ylab=&quot;Nombre de taches&quot;, col=period,type=&quot;p&quot;,pch=&quot;+&quot;) Exercise 1.4 (Layout) We consider the ozone dataset. With the layout function, split the window into two lines with the scatter plot maxO3 vs T12 on the first line; 2 graphs on the second lines: histogram of T12 et boxplot of maxO3. layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE)) plot(maxO3~T12,data=ozone) hist(ozone$T12) boxplot(ozone$maxO3) 1.2 Ggplot2 grammar ggplot2 is a plotting system for R based on the grammar of graphics (as dplyr to manipulate data). We can find documentation at http://ggplot2.org and https://ggplot2-book.org. 1.2.1 First charts with ggplot2 We consider a subsample of the diamond dataset from the package ggplot2 (or tidyverse): library(tidyverse) set.seed(1234) diamonds2 &lt;- diamonds[sample(nrow(diamonds),5000),] summary(diamonds2) carat cut color clarity Min. :0.2000 Fair : 158 D: 640 SI1 :1189 1st Qu.:0.4000 Good : 455 E: 916 VS2 :1157 Median :0.7000 Very Good:1094 F: 900 SI2 : 876 Mean :0.7969 Premium :1280 G:1018 VS1 : 738 3rd Qu.:1.0400 Ideal :2013 H: 775 VVS2 : 470 Max. :4.1300 I: 481 VVS1 : 326 J: 270 (Other): 244 depth table price Min. :43.00 Min. :49.00 Min. : 365 1st Qu.:61.10 1st Qu.:56.00 1st Qu.: 945 Median :61.80 Median :57.00 Median : 2376 Mean :61.76 Mean :57.43 Mean : 3917 3rd Qu.:62.50 3rd Qu.:59.00 3rd Qu.: 5294 Max. :71.60 Max. :95.00 Max. :18757 x y z Min. : 0.000 Min. :3.720 Min. :0.000 1st Qu.: 4.720 1st Qu.:4.720 1st Qu.:2.920 Median : 5.690 Median :5.700 Median :3.520 Mean : 5.728 Mean :5.731 Mean :3.538 3rd Qu.: 6.530 3rd Qu.:6.520 3rd Qu.:4.030 Max. :10.000 Max. :9.850 Max. :6.430 help(diamonds) A graph is always defined from many layers. We usually have to specify: the data the variables we want to plot the type of representation (scatterplot, boxplot…). Ggplot graphs are defined from these layers. We have to specify each layer with a ggplot function : the data with ggplot the variables with aes (aesthetics) the type of representation with geom_ These layers are gathered with the + operator. The scatterplot carat vs price is obtained with the plot function with plot(price~carat,data=diamonds2) With ggplot, we use ggplot(diamonds2) #nothing ggplot(diamonds2)+aes(x=carat,y=price) #nothing ggplot(diamonds2)+aes(x=carat,y=price)+geom_point() #OK Exercise 1.5 (Histograms and barplot with ggplot2) Draw the histogram of carat (use geom_histogram) ggplot(diamonds2)+aes(x=carat)+geom_histogram() Draw the histogram of carat with 10 bins (help(geom_histogram)) ggplot(diamonds2)+aes(x=carat)+geom_histogram(bins=10) Draw the barplot for the variable cut (use geom_bar) ggplot(diamonds2)+aes(x=cut)+geom_bar() To summarize, ggplot syntax is based on independent elements. These elements define the grammar of ggplot. Main elements of this grammar include: Data (ggplot): the dataset, it should be a dataframe or a tibble. Aesthetics (aes): to describe the way that variables in the data are mapped. We have to specify all variables used to build the graph in aes. Geometrics (geom_...): to control the type of plot (scaterplot, histogram…) Statistics (stat_...): to describe transformations of the data needed for the chart. Scales (scale_...): to control the mapping from data to aesthetic attributes (change of colors, options for the axis…) All these elements are combined with a +. 1.2.2 Data et aesthetics We have two use these elements for all graphs. ggplot verb is used to indicate the dataset. If the syntax is efficient, you will never have to use the name of the dataset to obtain the required graph. aes verb is used to specify the variables we want to visualize. For instance, for a scaterplot price vs carat, the syntax should start with ggplot(diamonds2)+aes(x=carat,y=price) aes also possesses options such as color, size, fill. We use these options as soon as a color or a size is defined from a variable of the dataset. For instance ggplot(diamonds2)+aes(x=carat,y=price,color=cut) 1.2.3 Geometrics To draw a graph, we need to specify the type of representation. We have to use geometrics to do that. For a scatter plot, we use geom_point: ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point() Observe that ggplot adds the lengend automatically. Examples of geometrics are described here: Table 1.1: Main geometrics Geom Description Aesthetics geom_point() Scatter plot x, y, shape, fill geom_line() Line (ordered according to x) x, y, linetype geom_abline() Line slope, intercept geom_path() Line (ordered according to the index) x, y, linetype geom_text() Text x, y, label, hjust, vjust geom_rect() Rectangle xmin, xmax, ymin, ymax, fill, linetype geom_polygon() Polygone x, y, fill, linetype geom_segment() Segment x, y, xend, yend, fill, linetype geom_bar() Barplot x, fill, linetype, weight geom_histogram() Histogram x, fill, linetype, weight geom_boxplot() Boxplots x, y, fill, weight geom_density() Density x, y, fill, linetype geom_contour() Contour lines x, y, fill, linetype geom_smooth() Smoothers (linear or non linear) x, y, fill, linetype All color, size, group Exercise 1.6 (Barplots) Draw the barplot of cut (with blue bars). ggplot(diamonds2)+aes(x=cut)+geom_bar(fill=&quot;blue&quot;) Draw the barplot of cut with one color for each modality of cut. Add a legend. ggplot(diamonds2)+aes(x=cut,fill=cut)+geom_bar() Draw the barplot of cut with one color of your choice for each modality of cut (and without lengend since it is not useful here). ggplot(diamonds)+aes(x=cut,fill=cut)+geom_bar(show.legend = FALSE)+ scale_fill_manual(values=c(&quot;Fair&quot;=&quot;blue&quot;,&quot;Good&quot;=&quot;red&quot;, &quot;Very Good&quot;=&quot;green&quot;,&quot;Premium&quot;=&quot;yellow&quot;, &quot;Ideal&quot;=&quot;black&quot;)) or (easier) we can specify directly the colors in geom_bar : ggplot(diamonds2)+aes(x=cut)+geom_bar(fill=c(&quot;blue&quot;,&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;black&quot;)) 1.2.4 Statistics Many graphs need transformations the data to make the representation. It is for example the case for histogram or barplot: we have to calculate the heights for rectangles or bars. These heigths are not explicitely specified in the dataset. Simple transformations can be obtained quickly with ggplot2. For instance we can draw the sine function with D &lt;- data.frame(X=seq(-2*pi,2*pi,by=0.01)) ggplot(D)+aes(x=X,y=sin(X))+geom_line() The sine transformation is indicated in aes. For more complex transformations, we have to used statistics. A stat function takes a dataset as input and returns another dataset as output, and so a stat can add new variables to the original dataset. It is then possible to map aesthetics to these new variables. For example, stat_bin function (used to build histograms) creates the following variables: count, the number of observations in each bin ; density, the density of observations in each bin (percentage of total / bar width) ; x, the center of the bin. By default geom_histogram represents on the \\(y\\)-axis the number of observations in each bin (the output count). ggplot(diamonds2)+aes(x=price)+geom_histogram(bins=40) If we are interested by another output of stat_bin, the density for instance, we have to use ggplot(diamonds2)+aes(x=price,y=..density..)+geom_histogram(bins=40) ggplot proposes another way to make the representations: we can use stat_ instead of geom_. Formally, each stat_… function has a geom_… and each geom_… has a stat_…. We can draw the same graph as above with ggplot(diamonds2)+aes(x=price,y=..density..)+stat_bin() Here are some examples of stat functions : Table 1.2: Examples of statistics. Stat Description Parameters stat_identity() No transformation stat_bin() Count binwidth, origin stat_density() Density adjust, kernel stat_smooth() Smoother method, se stat_boxplot() Boxplot coef stat and geom are not always easy to combine. For beginners, we recommend to use geom for beginners. Exercise 1.7 (A \"very simple\" barplot...) We consider a color variable \\(X\\) with probability distribution \\[P(X=red)=0.3,\\ P(X=blue)=0.2,\\ P(X=green)=0.4,\\ P(X=black)=0.1\\] Draw the barplot of this distribution. X &lt;- data.frame(X1=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;),prob=c(0.3,0.2,0.4,0.1)) ggplot(X)+aes(x=X1,y=prob,fill=X1)+geom_bar(stat=&quot;identity&quot;,show.legend = FALSE)+ labs(fill=&quot;Color&quot;)+xlab(&quot;&quot;) #or ggplot(X)+aes(x=X1,weight=prob)+geom_bar() Exercise 1.8 (Smoothing) Visualize the non linear smoother for the variable price in terms of carat. You can use geom_smooth or stat_smooth. ggplot(diamonds2)+aes(x=carat,y=price)+geom_smooth(method=&quot;loess&quot;) ggplot(diamonds2)+aes(x=carat,y=price)+stat_smooth(method=&quot;loess&quot;) Same question but use a dotted line instead of a solid line. ggplot(diamonds2)+aes(x=carat,y=price)+geom_smooth(method=&quot;loess&quot;,linetype=&quot;dotted&quot;) ggplot(diamonds2)+aes(x=carat,y=price)+stat_smooth(method=&quot;loess&quot;,geom=&quot;point&quot;) 1.2.5 Scales Scales control the mapping from data to aesthetic attributes (change of colors, sizes…). We generally use this element at the end of the process to refine the graph. Scales are defined as follows: begin with scale_ add the aesthetics we want to change (color, fill, x_) end with the name of the scale (manual, identity…) For instance, ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point()+ scale_color_manual(values=c(&quot;Fair&quot;=&quot;black&quot;,&quot;Good&quot;=&quot;yellow&quot;, &quot;Very Good&quot;=&quot;blue&quot;,&quot;Premium&quot;=&quot;red&quot;,&quot;Ideal&quot;=&quot;green&quot;)) Here are the main scales: Table 1.3: Main scales aes Discrete Continuous Color (color et fill) brewer gradient - grey gradient2 - hue gradientn - identity - manual Position (x and y) discrete continous - date Shape shape - identity - manual Size identity size - manual We now present some examples on scales: color in a barplot p1 &lt;- ggplot(diamonds2)+aes(x=cut)+geom_bar(aes(fill=cut)) p1 We change colors by using the palette Purples : p1+scale_fill_brewer(palette=&quot;Purples&quot;) Gradient color for a scatter plot : p2 &lt;- ggplot(diamonds2)+aes(x=carat,y=price)+geom_point(aes(color=depth)) p2 We change the gradient color p2+scale_color_gradient(low=&quot;red&quot;,high=&quot;yellow&quot;) Change on the axis p2+scale_x_continuous(breaks=seq(0.5,3,by=0.5))+scale_y_continuous(name=&quot;prix&quot;)+scale_color_gradient(&quot;Profondeur&quot;) 1.2.6 Group and facets ggplot allows to make representations for subgroup of individuals. We can proceed in two ways: to represent subgroup on the same graph =&gt; group in aes to represent subgroup on the different graphs =&gt; facets We represent (on the same graph) the smoother price vs carat for each modality of cut with ggplot(diamonds2)+aes(x=carat,y=price,group=cut)+ geom_smooth(method=&quot;loess&quot;) To obtain the representation on many graphs, we use ggplot(diamonds2)+aes(x=carat,y=price)+ geom_smooth(method=&quot;loess&quot;)+facet_wrap(~cut) ggplot(diamonds2)+aes(x=carat,y=price)+ geom_smooth(method=&quot;loess&quot;)+facet_wrap(~cut,nrow=1) facet_grid and facet_wrap do the same job but split the screen in different ways: ggplot(diamonds2)+aes(x=carat,y=price)+geom_point()+ geom_smooth(method=&quot;lm&quot;)+facet_grid(color~cut) ggplot(diamonds2)+aes(x=carat,y=price)+geom_point()+ geom_smooth(method=&quot;lm&quot;)+facet_wrap(color~cut) 1.3 Complements Syntax for ggplot is defined according to the following process: ggplot()+aes()+geom_()+scale_() It is really flexible: for instance aes could also be specified in ggplot or in geom_ ggplot(diamonds2)+aes(x=carat,y=price)+geom_point() ggplot(diamonds2,aes(x=carat,y=price))+geom_point() ggplot(diamonds2)+geom_point(aes(x=carat,y=price)) It could be very useful when we want to use different aes in the geom_ We can also build a chart from many dataset: X &lt;- seq(-2*pi,2*pi,by=0.001) Y1 &lt;- cos(X) Y2 &lt;- sin(X) donnees1 &lt;- data.frame(X,Y1) donnees2 &lt;- data.frame(X,Y2) ggplot(donnees1)+geom_line(aes(x=X,y=Y1))+ geom_line(data=donnees2,aes(x=X,y=Y2),color=&quot;red&quot;) Many other functions are proposed by ggplot: ggtitle to add a title. ggsave ta save a graph. theme_ to change the theme of the graph. p &lt;- ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point() p+theme_bw() p+theme_classic() p+theme_grey() p+theme_bw() Many other themes are available in the ggtheme package. The function set_theme can be used to change the default theme in a markdown document. 1.4 Some exercises Exercise 1.9 (Cosine and sine functions...) Draw the sine and cosine functions on the same graph. You first have to use two datasets (one for the sine function, the other for the cosine function). X &lt;- seq(-2*pi,2*pi,by=0.001) Y1 &lt;- cos(X) Y2 &lt;- sin(X) donnees1 &lt;- data.frame(X,Y1) donnees2 &lt;- data.frame(X,Y2) ggplot(donnees1)+aes(x=X)+geom_line(aes(y=Y1))+ geom_line(data=donnees2,aes(y=Y2),color=&quot;red&quot;) Do the same with one dataset and 2 geom_line. donnees &lt;- data.frame(X,Y1,Y2) ggplot(donnees)+aes(x=X,y=Y1)+geom_line()+ geom_line(aes(y=Y2),color=&quot;red&quot;) #or for the legend ggplot(donnees)+aes(x=X,y=Y1)+geom_line(aes(color=&quot;cos&quot;))+ geom_line(aes(y=Y2,color=&quot;sin&quot;))+labs(color=&quot;Fonction&quot;) Do the same with one dataset and one geom_line. Hint: use the pivot_longer function from the tidyverse package. df &lt;- data.frame(X,cos=Y1,sin=Y2) df1 &lt;- df |&gt; pivot_longer(cols=c(cos,sin), names_to = &quot;Fonction&quot;, values_to = &quot;value&quot;) #or df1 &lt;- df |&gt; pivot_longer(cols=-X, names_to = &quot;Fonction&quot;, values_to = &quot;value&quot;) ggplot(df1)+aes(x=X,y=value,color=Fonction)+geom_line() Draw the two functions on two different graphs (use facet_wrap). ggplot(df1)+aes(x=X,y=value)+geom_line()+facet_wrap(~Fonction) Do the same with the function grid.arrange from the package gridExtra. library(gridExtra) p1 &lt;- ggplot(donnees1)+aes(x=X,y=Y1)+geom_line() p2 &lt;- ggplot(donnees2)+aes(x=X,y=Y2)+geom_line() grid.arrange(p1,p2,nrow=1) Exercise 1.10 (Classical representations for a dataset) We consider the mtcars dataset: data(mtcars) summary(mtcars) mpg cyl disp Min. :10.40 Min. :4.000 Min. : 71.1 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 Median :19.20 Median :6.000 Median :196.3 Mean :20.09 Mean :6.188 Mean :230.7 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 Max. :33.90 Max. :8.000 Max. :472.0 hp drat wt Min. : 52.0 Min. :2.760 Min. :1.513 1st Qu.: 96.5 1st Qu.:3.080 1st Qu.:2.581 Median :123.0 Median :3.695 Median :3.325 Mean :146.7 Mean :3.597 Mean :3.217 3rd Qu.:180.0 3rd Qu.:3.920 3rd Qu.:3.610 Max. :335.0 Max. :4.930 Max. :5.424 qsec vs am Min. :14.50 Min. :0.0000 Min. :0.0000 1st Qu.:16.89 1st Qu.:0.0000 1st Qu.:0.0000 Median :17.71 Median :0.0000 Median :0.0000 Mean :17.85 Mean :0.4375 Mean :0.4062 3rd Qu.:18.90 3rd Qu.:1.0000 3rd Qu.:1.0000 Max. :22.90 Max. :1.0000 Max. :1.0000 gear carb Min. :3.000 Min. :1.000 1st Qu.:3.000 1st Qu.:2.000 Median :4.000 Median :2.000 Mean :3.688 Mean :2.812 3rd Qu.:4.000 3rd Qu.:4.000 Max. :5.000 Max. :8.000 Draw the histogram of mpg (use many number of bins). ggplot(mtcars)+aes(x=mpg)+geom_histogram() ggplot(mtcars)+aes(x=mpg)+geom_histogram(bins=10) Always for the histogram, represent the density on the \\(y\\)-axis. ggplot(mtcars)+aes(x=mpg,y=..density..)+geom_histogram(bins=10) Draw the barplot of cyl. ggplot(mtcars)+aes(x=cyl)+geom_bar() Draw the scatter plot disp vs mpg with one color for each value of cyl. ggplot(mtcars)+aes(x=disp,y=mpg,color=cyl)+geom_point() ggplot(mtcars)+aes(x=disp,y=mpg,color=as.factor(cyl))+geom_point()+labs(color=&quot;cyl&quot;) Add the linear smoothers, one linear smoother for each value of cyl. ggplot(mtcars)+aes(x=disp,y=mpg,color=as.factor(cyl))+geom_point()+ geom_smooth(method=&quot;lm&quot;)+labs(color=&quot;cyl&quot;) Exercise 1.11 (Residuals for a simple regression model) Simulate a sample \\((x_i,y_i),i=1,\\dots,100\\) according to the linear model \\[y_i=3+x_i+\\varepsilon_i\\] where the \\(x_i\\)’s are i.i.d. with uniform distribution over \\([0,1]\\) and \\(\\varepsilon_i\\)’s are gaussian \\(N(0,0.2^2)\\) (use runif and rnorm) n &lt;- 100 X &lt;- runif(n) eps &lt;- rnorm(n,sd=0.2) Y &lt;- 3+X+eps D &lt;- data.frame(X,Y) Draw the scatter plot y vs x and add the linear smoother. We first do that “step by step” by computing the linear smoother. model &lt;- lm(Y~.,data=D) co &lt;- coef(model) D$fit &lt;- predict(model) co &lt;- coef(lm(Y~.,data=D)) ggplot(D)+aes(x=X,y=Y)+geom_point()+ geom_abline(slope=co[2],intercept=co[1],color=&quot;blue&quot;) We can do the same more quickly with geom_smooth. ggplot(D)+aes(x=X,y=Y)+geom_point()+geom_smooth(method=&quot;lm&quot;) Draw the residuals: add a vertical line from each point to the linear smoother (use geom_segment). ggplot(D)+aes(x=X,y=Y)+geom_point()+geom_smooth(method=&quot;lm&quot;)+ geom_segment(aes(xend=X,yend=fit)) Exercise 1.12 (Challenge) We consider the diamonds dataset. Draw the following graphs (use coord_flip for the second one). We obtain the required graphs with: ggplot(data=diamonds) + geom_boxplot(aes(x=cut,y=carat,fill=cut)) ggplot(data=diamonds) + geom_boxplot(aes(x=carat,y=cut,fill=cut)) ggplot(data=diamonds) + geom_density(aes(x=carat,y=..density..)) + facet_grid(cut~.) Add on the third graph a vertical line for the quartiles of the variable carat (for each value of cut). Q1 &lt;- diamonds |&gt; group_by(cut) |&gt; summarize(q1=quantile(carat,c(0.25)),q2=quantile(carat,c(0.5)), q3=quantile(carat,c(0.75))) quantildf &lt;- Q1 |&gt; pivot_longer(-cut,names_to=&quot;alpha&quot;,values_to=&quot;quantiles&quot;) ggplot(data=diamonds) + geom_density(aes(x=carat,y=..density..)) + facet_grid(cut~.) + geom_vline(data=quantildf,aes(xintercept=quantiles),col=alpha(&quot;black&quot;,1/2)) We can also use stat_boxplot: ggplot(data=diamonds) + aes(x=carat)+ geom_density() + stat_boxplot(aes(xintercept=c(..xlower..,..xmiddle.., ..xupper..)),geom=&quot;vline&quot;) + facet_grid(cut~.) or stat_summary : diamonds |&gt; ggplot(aes(x=carat)) + geom_density() + stat_summary(mapping=aes(y=1,xintercept=after_stat(x)),fun=&quot;quantile&quot;, fun.args = list(prob=c(0.25,0.5,0.75)), geom=&quot;vline&quot;,orientation=&quot;y&quot;) + facet_grid(cut~.) Add a horizontal boxplot under each graph to obtain the following chart: We obtain the required graph with: ggplot(data=diamonds) + geom_boxplot(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) + geom_density(aes(x=carat,y=..density..)) + facet_grid(cut~.) + geom_vline(data=quantildf,aes(xintercept=quantiles),col=alpha(&quot;black&quot;,1/2)) + ylab(&quot;&quot;) or ggplot(data=diamonds) + aes(x=carat)+ geom_boxplot(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) + geom_density() + stat_boxplot(aes(xintercept=c(..xlower..,..xmiddle.., ..xupper..)),geom=&quot;vline&quot;) + facet_grid(cut~.)+ylab(&quot;&quot;) or with stat_summary : diamonds |&gt; ggplot(aes(x=carat)) + geom_boxplot(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) + geom_density() + stat_summary(mapping=aes(y=1,xintercept=after_stat(x)),fun=&quot;quantile&quot;, fun.args = list(prob=c(0.25,0.5,0.75)), geom=&quot;vline&quot;,orientation=&quot;y&quot;) + facet_grid(cut~.) + ylab(&quot;&quot;) "],["mapping.html", "Chapter 2 Mapping with R 2.1 ggmap package 2.2 Maps with contours, shapefile format 2.3 Dynamic maps with leaflet", " Chapter 2 Mapping with R Many datasets contains informations about location. It is natural to use map to visualize these data. We can differentiate two kind of maps: static map: to be exported in pdf or png format, usefull to publish report; dynamic or interactive map: to be exported in html format for instance. We can visualize these maps in a web browser and add informations when we click on the map. Many R packages exist for mapping. In this chapter, we present ggmap and sf for static map and leaflet for dynamic map. 2.1 ggmap package We show in this part how to get background map and add informations from a dataset with ggmap package. For more details, we refer to this article It is quite easy to download background map, for instance library(ggmap) us &lt;- c(left = -125, bottom = 25.75, right = -67, top = 49) map &lt;- get_stamenmap(us, zoom = 5, maptype = &quot;toner-lite&quot;) ggmap(map) For Europe we can use europe &lt;- c(left = -12, bottom = 35, right = 30, top = 63) get_stamenmap(europe, zoom = 5,&quot;toner-lite&quot;) |&gt; ggmap() We can change the type of the background map get_stamenmap(europe, zoom = 5,&quot;toner-background&quot;) |&gt; ggmap() Here is an example for France fr &lt;- c(left = -6, bottom = 41, right = 10, top = 52) get_stamenmap(fr, zoom = 5,&quot;toner-lite&quot;) |&gt; ggmap() geocode function from ggmap made it possible to get latitudes and longitudes from a location. An API is now needed to use it (we could have to pay). We propose to use the following function instead: if (!(require(jsonlite))) install.packages(&quot;jsonlite&quot;) mygeocode &lt;- function(adresses){ # adresses est un vecteur contenant toutes les adresses sous forme de chaine de caracteres nominatim_osm &lt;- function(address = NULL){ ## details: http://wiki.openstreetmap.org/wiki/Nominatim ## fonction nominatim_osm proposée par D.Kisler if(suppressWarnings(is.null(address))) return(data.frame()) tryCatch( d &lt;- jsonlite::fromJSON( gsub(&#39;\\\\@addr\\\\@&#39;, gsub(&#39;\\\\s+&#39;, &#39;\\\\%20&#39;, address), &#39;http://nominatim.openstreetmap.org/search/@addr@?format=json&amp;addressdetails=0&amp;limit=1&#39;) ), error = function(c) return(data.frame()) ) if(length(d) == 0) return(data.frame()) return(c(as.numeric(d$lon), as.numeric(d$lat))) } tableau &lt;- t(sapply(adresses,nominatim_osm)) colnames(tableau) &lt;- c(&quot;lon&quot;,&quot;lat&quot;) return(tableau) } We can get latitudes and longitudes with mygeocode(&quot;the white house&quot;) lon lat the white house -77.03655 38.8977 mygeocode(&quot;Paris&quot;) lon lat Paris 2.320041 48.85889 mygeocode(&quot;Rennes&quot;) lon lat Rennes -1.68002 48.11134 Exercise 2.1 (Population sizes in France) The goal is to visualize some French cities. Find latitudes and longitudes for Paris, Lyon and Marseille and represent these cities on a map (you can use a dot). V &lt;- c(&quot;Paris&quot;,&quot;Lyon&quot;,&quot;Marseille&quot;) A &lt;- mygeocode(V) A &lt;- A |&gt; as_tibble() |&gt; mutate(Villes=V) fr &lt;- c(left = -6, bottom = 41, right = 10, top = 52) fond &lt;- get_stamenmap(fr, zoom = 5,&quot;toner-lite&quot;) ggmap(fond)+geom_point(data=A,aes(x=lon,y=lat),color=&quot;red&quot;) File villes_fr.csv contains population sizes for 30 cities in France. Visualize these cities by adding points in the previous map. We will use different point sizes in term of populations sizes in 2014. df &lt;- read_csv(&quot;data/villes_fr.csv&quot;) df$Commune &lt;- as.character(df$Commune) Be careful, the city of Lille is not correctly specified! We have to rename it: df$Commune[10] [1] &quot;Lille15&quot; df$Commune[10] &lt;- &quot;Lille&quot; We can now compute coordinates with mygeocode and visualize the cities. For point size, we just have to use size=‘2014’ in the option aes of the function geom_point. coord &lt;- mygeocode(as.character(df$Commune)) |&gt; as_tibble() df1 &lt;- bind_cols(df,coord) ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat),color=&quot;red&quot;) ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat,size=`2014`),color=&quot;red&quot;) 2.2 Maps with contours, shapefile format ggmpap makes it easy to download background map and to add informations with ggplot functions. However, it is more difficult to take into account of contours (boundaries for countries or department…). We propose here an introduction to the sf package. It allows to create “advanced” maps, by managing boundaries through specific objects. Moreover we can manage many coordinate systmes with this package. Recall that earth is not flat… But we usually visualize a map in 2D. We thus have to make projections in order to visualize locations defined by a coordinate (latitude and longitude for instance). These projections are generally managed by the packages, it is the case of sf. We can find documentation on this package at: https://statnmap.com/fr/2018-07-14-initiation-a-la-cartographie-avec-sf-et-compagnie/ in the vignettes of the documentation of the package: https://cran.r-project.org/web/packages/sf/index.html Package sf allows to define a new class of R objects specific for mapping. Look at the object nc library(sf) nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) class(nc) [1] &quot;sf&quot; &quot;data.frame&quot; nc Simple feature collection with 100 features and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 Geodetic CRS: NAD27 First 10 features: AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO 1 0.114 1.442 1825 1825 Ashe 37009 37009 2 0.061 1.231 1827 1827 Alleghany 37005 37005 3 0.143 1.630 1828 1828 Surry 37171 37171 4 0.070 2.968 1831 1831 Currituck 37053 37053 5 0.153 2.206 1832 1832 Northampton 37131 37131 6 0.097 1.670 1833 1833 Hertford 37091 37091 7 0.062 1.547 1834 1834 Camden 37029 37029 8 0.091 1.284 1835 1835 Gates 37073 37073 9 0.118 1.421 1836 1836 Warren 37185 37185 10 0.124 1.428 1837 1837 Stokes 37169 37169 CRESS_ID BIR74 SID74 NWBIR74 BIR79 SID79 NWBIR79 1 5 1091 1 10 1364 0 19 2 3 487 0 10 542 3 12 3 86 3188 5 208 3616 6 260 4 27 508 1 123 830 2 145 5 66 1421 9 1066 1606 3 1197 6 46 1452 7 954 1838 5 1237 7 15 286 0 115 350 2 139 8 37 420 0 254 594 2 371 9 93 968 4 748 1190 2 844 10 85 1612 1 160 2038 5 176 geometry 1 MULTIPOLYGON (((-81.47276 3... 2 MULTIPOLYGON (((-81.23989 3... 3 MULTIPOLYGON (((-80.45634 3... 4 MULTIPOLYGON (((-76.00897 3... 5 MULTIPOLYGON (((-77.21767 3... 6 MULTIPOLYGON (((-76.74506 3... 7 MULTIPOLYGON (((-76.00897 3... 8 MULTIPOLYGON (((-76.56251 3... 9 MULTIPOLYGON (((-78.30876 3... 10 MULTIPOLYGON (((-80.02567 3... This dataset contains informations about sudden infant death syndrome in North Carolina counties. We observe 2 classes for nc: sf and data.frame. We can manage it as a classical dataframe. sf class allows to define a particular column (geometry) in which we can specify boundaries of the counties with polygon. This column makes it easy to plot these boundaries (with polygon) in a map. We can use the classicat plot function plot(st_geometry(nc)) or the geom_sf verb if we prefer ggplot ggplot(nc)+geom_sf() It is now easy to color counties and to add their names ggplot(nc[1:3,]) + geom_sf(aes(fill = AREA)) + geom_sf_label(aes(label = NAME)) geometry column of nc uses MULTIPOLYGON. This allows to represent boundaries. If we want to represent one country by a point, we have to change the format of this column. We can do it as follows : We first compute latitude and longitude for each country: coord.ville.nc &lt;- mygeocode(paste(as.character(nc$NAME),&quot;NC&quot;)) coord.ville.nc &lt;- as.data.frame(coord.ville.nc) names(coord.ville.nc) &lt;- c(&quot;lon&quot;,&quot;lat&quot;) We give to these coordinates the format MULTIPOINT (st_multipoint function) coord.ville1.nc &lt;- coord.ville.nc |&gt; filter(lon&lt;=-77 &amp; lon&gt;=-85 &amp; lat&gt;=33 &amp; lat&lt;=37) |&gt; as.matrix() |&gt; st_multipoint() |&gt; st_geometry() |&gt; st_cast(to=&quot;POINT&quot;) coord.ville1.nc Geometry set for 79 features Geometry type: POINT Dimension: XY Bounding box: xmin: -84.08862 ymin: 33.93323 xmax: -77.01151 ymax: 36.503 CRS: NA First 5 geometries: We indicate that these coordinates correspond to longitudes and latitudes (there exists other coordinate systmes): st_crs(coord.ville1.nc) &lt;- 4326 We can now visualize both the boundaries and the counties: ggplot(nc)+geom_sf()+geom_sf(data=coord.ville1.nc) There are many useful functions in sf to deal with mapping data, for instance st_distance to compute (real) distances between coordinates; st_centroid to obtain the center of a polygon (or region); … For example we con visualize the centers of the areas identified by the polygons in nc with nc2 &lt;- nc |&gt; mutate(centre=st_centroid(nc)$geometry) ggplot(nc2)+geom_sf()+geom_sf(aes(geometry=centre)) Exercise 2.2 (A first map with sf) We consider the GEOFLAR map proposed by “l’Institut Géographique National” to obtain a shapefile background map of the french departments. This map is available at http: //professionnels.ign.fr/, we can obtain it in the file dpt.zip (you have to unzip this file). We can import this map into a R object with dpt &lt;- read_sf(&quot;data/dpt&quot;) ggplot(dpt) + geom_sf() Redo the map of exercise 2.1 with this background map. We first define one geometry with format MULTIPOINT. We then convert it into a “vector” of length 30 with format POINT. We finally add this vector in the dataframe which contains coordinates of the counties. coord.ville1 &lt;- tibble(df1[,14:15]) |&gt; as.matrix() |&gt; st_multipoint() |&gt; st_geometry() coord.ville2 &lt;- st_cast(coord.ville1, to = &quot;POINT&quot;) coord.ville1 Geometry set for 1 feature Geometry type: MULTIPOINT Dimension: XY Bounding box: xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657 CRS: NA coord.ville2 Geometry set for 30 features Geometry type: POINT Dimension: XY Bounding box: xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657 CRS: NA First 5 geometries: We can now obtain the required map: st_geometry(df1) &lt;- coord.ville2 st_crs(df1) &lt;- 4326 ggplot(dpt)+geom_sf(fill=&quot;white&quot;)+ geom_sf(data=df1,aes(size=`2014`),color=&quot;red&quot;)+theme_void() Exercise 2.3 (Unemployment rates) We want to visualize differences between unemployment rates in 2006 and 2011. The data are in the file tauxchomage.csv. We are interested in variables TCHOMB1T06 and TCHOMB1T11. Read the dataset. chomage &lt;- read_delim(&quot;data/tauxchomage.csv&quot;,delim=&quot;;&quot;) Merge this dataset with the one of the department. You can use inner_join. dpt &lt;- read_sf(&quot;data/dpt&quot;) dpt2 &lt;- inner_join(dpt,chomage,by=&quot;CODE_DEPT&quot;) Make a comparison between the unemployment rates in 2006 and 2011 (build one map for 2006 and another one for 2011). dpt3 &lt;- dpt2 |&gt; select(A2006=TCHOMB1T06,A2011=TCHOMB1T11,geometry) |&gt; as_tibble() |&gt; pivot_longer(-geometry,names_to=&quot;Annee&quot;,values_to=&quot;TxChomage&quot;) |&gt; st_as_sf() ggplot(dpt3) + aes(fill = TxChomage)+geom_sf() + facet_wrap(~Annee, nrow = 1)+ scale_fill_gradient(low=&quot;white&quot;,high=&quot;brown&quot;)+theme_bw() 2.2.1 Challenge 1: temperature map with sf We want to visualize temperatures in france far a given date. Data are available on the website of public data of meteofrance. In particular we focus on the observed temperatures in some french stations in the link téléchargement. We just have to keep the Idof the station and the observed temperature (column t). the location of these stations available in documentation Import the 2 required dataset (you can read those directly on the website). Temperatures are given in Kelvin. Convert them in Celsius (you just have to substract 273.15). Keep only stations from metropolitan france (remove stations from overseas department). Hint: You can keep only stations with longitude between -20 and 25. We call this dataset station1. Visualize stations on a french map with boundaries department. Create a dataframe (with sf format) which contains temperatures of the stations in one column and a column geometry with the coordinate of these stations. We can start with station2 &lt;- station1 |&gt; select(Longitude,Latitude) |&gt; as.matrix() |&gt; st_multipoint() |&gt; st_geometry() st_crs(station2) &lt;- 4326 station2 &lt;- st_cast(station2, to = &quot;POINT&quot;) Visualize the stations in the french map. You can color the points (stations) according to the observed temperatures. We obtain coordinates of the centroids of the departments with centro &lt;- st_centroid(dpt$geometry) centro &lt;- st_transform(centro,crs=4326) We then deduce distances between these centroids and the stations (here df is the sf table computed in question 3). DD &lt;- st_distance(df,centro) Predict the temperature in each department with a one nearest neighbour rule (temperature of department \\(i\\) is the temperature of the nearest station of \\(i\\)). Color departments according to the predicted temperatures. We can use a gradient color from yellow (for low temperatures) to red (for high temperatures). 2.2.2 Finding background shapefile map We usually need background shapefile map to build a map with sf. Many solution exists: some R packages, for instance rnaturalearth: world &lt;- rnaturalearth::ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) class(world) [1] &quot;sf&quot; &quot;data.frame&quot; ggplot(data = world) + geom_sf(aes(fill = pop_est)) + scale_fill_viridis_c(option = &quot;plasma&quot;, trans = &quot;sqrt&quot;)+theme_void() We can also visualize earth as a sphere: ggplot(data = world) + geom_sf() + coord_sf(crs = &quot;+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs &quot;) See https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html for more details. the web, for instance on data gouv: regions &lt;- read_sf(&quot;data/regions-20180101-shp/&quot;) Be careful, sometimes the object size can be very large: format(object.size(regions),units=&quot;Mb&quot;) [1] &quot;15.4 Mb&quot; The construction of the map could be time consuming in this case, we have to reduce the size before building the map: library(rmapshaper) regions1 &lt;- ms_simplify(regions) format(object.size(regions1),units=&quot;Mb&quot;) [1] &quot;0.9 Mb&quot; ggplot(regions1)+geom_sf()+ coord_sf(xlim = c(-5.5,10),ylim=c(41,51))+theme_void() 2.3 Dynamic maps with leaflet Leaflet is a R package which allows to produce interactive maps. You can find informations about this pakage at https://rstudio.github.io/leaflet/. The ideas are quite the same as for ggmap and sf: maps are defined from many layers. A leaflet background map can be created with library(leaflet) leaflet() |&gt; addTiles() Many formats of background maps are available (some examples here). For instance Paris &lt;- mygeocode(&quot;paris&quot;) m2 &lt;- leaflet() |&gt; setView(lng = Paris[1], lat = Paris[2], zoom = 12) |&gt; addTiles() m2 |&gt; addProviderTiles(&quot;Stamen.Toner&quot;) m2 |> addProviderTiles(\"Wikimedia\") m2 |> addProviderTiles(\"Esri.NatGeoWorldMap\") m2 |> addProviderTiles(\"Stamen.Watercolor\") |> addProviderTiles(\"Stamen.TonerHybrid\") We can identify places with markers or circles data(quakes) leaflet(data = quakes[1:20,]) |&gt; addTiles() |&gt; addMarkers(~long, ~lat, popup = ~as.character(mag)) Observe that we have to use the tilda character ~ when we want to use column names of the dataframe. The dynamic process can be used to add information when we click on a marker (with popup option). We can also add popups as follows content &lt;- paste(sep = &quot;&lt;br/&gt;&quot;, &quot;&lt;b&gt;&lt;a href=&#39;http://www.samurainoodle.com&#39;&gt;Samurai Noodle&lt;/a&gt;&lt;/b&gt;&quot;, &quot;606 5th Ave. S&quot;, &quot;Seattle, WA 98138&quot; ) leaflet() |&gt; addTiles() |&gt; addPopups(-122.327298, 47.597131, content, options = popupOptions(closeButton = FALSE) ) Exercise 2.4 (Popup with leaflet) Use a popup on a leaflet map which locate Ensai with the website of the school. 2.3.1 Challenge 2: bike stations in Paris Many cities all over the world provides informations on bike stations. These data are easily available et are updated in real time. Among other, we have informations about the size, the location, the number of available bikes for each stations. We can obtain these data on Decaux Open data Paris vlstats Import informations onbike stations in Paris for today: https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/information/. You can use read_delim function with delim=\";\". Describe the dataset. Create variables latitude and longitude from the column Coordonnées géographiques. You can use the verb separate from the tidyr package. Visualize the stations on a leaflet background map. Add a popup which indicates the number of available bikes (electric+mecanic) when we click on the station (you can use the popup option in the function addCircleMarkers). Add the name of the station in the popup. Do the same with different colors to visualize the proportion of available bikes in the station. You can use the color palettes ColorPal1 &lt;- colorNumeric(scales::seq_gradient_pal(low = &quot;#132B43&quot;, high = &quot;#56B1F7&quot;, space = &quot;Lab&quot;), domain = c(0,1)) ColorPal2 &lt;- colorNumeric(scales::seq_gradient_pal(low = &quot;red&quot;, high = &quot;black&quot;, space = &quot;Lab&quot;), domain = c(0,1)) Create a R function local.station which allows to visualize the closest stations of a given station. For instance local.station(&quot;Jussieu - Fossés Saint-Bernard&quot;) local.station(\"Gare Montparnasse - Arrivée\") 2.3.2 Temperature map with leaflet Exercise 2.5 (Challenge) Redo the temperature map of the first challenge (see section 2.2.1) with leaflet. We will use the table build at the end of the challenge with the function addPolygons. We can also add a popup to visualize the name of the department and the predicted temperature when we click on the map. "],["dynamic.html", "Chapter 3 Dynamic visualization 3.1 Basic charts with rAmCharts and plotly 3.2 Graphs to visualize networks with visNetwork 3.3 Dashboard", " Chapter 3 Dynamic visualization As for leaflet for mapping, there exists many R packages for dynamic or interactive visualization. We present some of them in this part. 3.1 Basic charts with rAmCharts and plotly rAmCharts is user-friendly for standard graphs (scatterplot, times series, histogram…). We just have to use classical R functions with the prefix am. For instance library(rAmCharts) amHist(iris$Petal.Length) amPlot(iris, col = colnames(iris)[1:2], type = c(&quot;l&quot;, &quot;st&quot;), zoom = TRUE, legend = TRUE) amBoxplot(iris) plotly produces similar things but with a specific syntax. plotly commands are expanded into 3 parts: dataset and variables (plot_ly}) ; additional representaions (add_trace, add_markers…) ; options (axis, titles…) (layout). We can find a description for each part at https://plot.ly/r/reference/. As a first chart, we propose to represent a scatterplot with its linear smoother. We start by generating the data and computing the linear model: library(plotly) n &lt;- 100 X &lt;- runif(n,-5,5) Y &lt;- 2+3*X+rnorm(n,0,1) D &lt;- data.frame(X,Y) model &lt;- lm(Y~X,data=D) We obtain the required graph with D %&gt;% plot_ly(x=~X,y=~Y) %&gt;% add_markers(type=&quot;scatter&quot;,mode=&quot;markers&quot;, marker=list(color=&quot;red&quot;),name=&quot;Nuage&quot;) %&gt;% add_trace(y=fitted(model),type=&quot;scatter&quot;,mode=&#39;lines&#39;, name=&quot;Régression&quot;,line=list(color=&quot;blue&quot;)) %&gt;% layout(title=&quot;Régression&quot;,xaxis=list(title=&quot;abscisse&quot;), yaxis=list(title=&quot;ordonnées&quot;)) Unlike ggplot, we can make 3D with plotly. For instance plot_ly(z = volcano, type = &quot;surface&quot;) plot_ly(z = volcano, type = \"contour\") We can also convert ggplot graph into plotly graph with ggplotly: p &lt;- ggplot(iris)+aes(x=Species,y=Sepal.Length)+geom_boxplot()+theme_classic() ggplotly(p) You can find more informations in this book. Exercise 3.1 (Basic charts with `rAmCharts` and `plotly`) We consider the iris dataset. Build the following graph with rAmCharts and plotly. Scatterplot Sepal.Length in term of Sepal.Width. Use different colors for each species. Boxplot to visualize the distribution of Petal.Length for each species. 3.2 Graphs to visualize networks with visNetwork Many datasets can be visualized with graphs, especially when one has to study connections between individuals. In this case, each individual is represented by a node and we use edges for the connections. igraph package proposes static representations for graph. For dynamic graphs, we can use visNetwork. To obtain dynamic graphs, we first have to specify nodes and edges, for instance nodes &lt;- data.frame(id = 1:15, label = paste(&quot;Id&quot;, 1:15), group=sample(LETTERS[1:3], 15, replace = TRUE)) edges &lt;- data.frame(from = trunc(runif(15)*(15-1))+1,to = trunc(runif(15)*(15-1))+1) library(visNetwork) visNetwork(nodes,edges) visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE) visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) visNetwork(nodes, edges) %&gt;% visOptions(selectedBy = &quot;group&quot;) Exercise 3.2 (Connections between medias) We consider a graph which represents connections between medias. Data are available here. We can import them with nodes &lt;- read.csv(&quot;data/Dataset1-Media-Example-NODES.csv&quot;, header=T, as.is=T) links &lt;- read.csv(&quot;data/Dataset1-Media-Example-EDGES.csv&quot;, header=T, as.is=T) head(nodes) id media media.type type.label 1 s01 NY Times 1 Newspaper 2 s02 Washington Post 1 Newspaper 3 s03 Wall Street Journal 1 Newspaper 4 s04 USA Today 1 Newspaper 5 s05 LA Times 1 Newspaper 6 s06 New York Post 1 Newspaper audience.size 1 20 2 25 3 30 4 32 5 20 6 50 head(links) from to weight type 1 s01 s02 10 hyperlink 2 s01 s02 12 hyperlink 3 s01 s03 22 hyperlink 4 s01 s04 21 hyperlink 5 s04 s11 22 mention 6 s05 s15 21 mention nodes object represents the nodes (normal) while links is for the edges. We can obtain a graph object with library(igraph) media &lt;- graph_from_data_frame(d=links, vertices=nodes, directed=T) V(media)$name &lt;- nodes$media and we can visualize the (static) graph with a simple plot: plot(media) Visualize this graph with VisNetwork package. Hint: use toVisNetworkData. Add an option which allows to select the type of media (Newspaper, TV or Online). Use different colors for each media. Use arrows with different widths according to the variable weight. We can also add the option visOptions(highlightNearest = TRUE). 3.3 Dashboard Dashboards are very important tools in datascience. They allow to gather important messages on datasets and/or a models. We can build dashboard in R with the package flexdashboard. The syntax is based on Rmarkdown, we don’t have to learn new tools. We can find a very nice tutorial on this package at https://rmarkdown.rstudio.com/flexdashboard/. You can use this tutorial to make the following exercise. Exercise 3.3 (A Dashboard for linear models) We consider the dataset ozone.txt. The goal is to explain the maximum daily ozone concentration (variable maxO3) by the other variables (information about temperatures, nebulosity, wind…). We want to make a dashboard to visualize the data : the database and two or three graphs about the output variables (maxO3); visualize simple linear models: we choose one input and we obtain the scatterplot and the linear smoother; visualize the full linear model: a summary of the models with some graphs about the residuals; select the inputs in the linear models; … As a first step, we propose to write some simple functions for the dashboard. We only consider numeric variables. Visualize correlations between the variables with the corrplot function of the corrplot package. Draw the histogram of maxO3 with ggplot, rAmCharts and plotly (use ggplotly). Fit the linear model with output maxO3 (all the other variables as input). Calculate the Studentized residuals (rstudent) and visualize these residuals in term of maxO3. You can also add a linear smoother on the graph. We can now start the dashboard. Use File -&gt; Rmarkdown -&gt; From Template -&gt; Flex Dashboard dialog to open a script. Build a first dashboard which allows to visualize the dataset on a column (use datatable function from DT package) ; the histogram of maxO3 and the correlation matrix on a second column. Add a second tab to visualize the summary of the full linear model. You can use datatable function of DT package. Hint: a new tab could be added with Add another tab to visualize a simple linear model with one input of your choice. You can print in this tab both the summary of the model and the scatter plot with the linear smoother. Taking things further: add a last tab where the user can select an input for the linear model. Hint: use the following Shiny commands: Input choice radioButtons(&quot;variable1&quot;, label=&quot;Choisir la variable explicative&quot;, choices=names(df)[-1], selected=list(&quot;T9&quot;)) Interactive summary mod1 &lt;- reactive({ XX &lt;- paste(input$variable1,collapse=&quot;+&quot;) form &lt;- paste(&quot;maxO3~&quot;,XX,sep=&quot;&quot;) %&gt;% formula() lm(form,data=df) }) #Df corresponds to the dataset renderDataTable({ mod.sum1 &lt;- summary(mod1())$coefficients %&gt;% round(3) %&gt;% as.data.frame() DT::datatable(mod.sum1,options = list(dom = &#39;t&#39;)) }) Interactive graph renderPlotly({ (ggplot(df)+aes(x=!!as.name(input$variable1),y=maxO3)+ geom_point()+geom_smooth(method=&quot;lm&quot;)) %&gt;% ggplotly() }) Don’t forget to add runtime: shiny in the header. The final dashboard may look like It is available at https://lrouviere.shinyapps.io/dashboard/. "],["shiny-web-applications.html", "Chapter 4 Shiny web applications 4.1 First app 4.2 Input - output 4.3 Organizing the application 4.4 Adding interactive charts 4.5 Reactive, isolation, observe, html, … 4.6 Some additional exercises", " Chapter 4 Shiny web applications This part comes from the tutorial of Benoît Thieurmel. It is available here https://github.com/datastorm-open/tuto_shiny_rennes. 4.1 First app Create a new repository for the application (in RStudio): File -&gt; New Project -&gt; New Directory -&gt; Shiny Web Application Choose an application Multiple File. If the option Multiple File (it depends on the version of Rstudio) is not possible, you can use File -&gt; New File -&gt; Shiny Web App -&gt; Multiple File Two files are automatically created: ui.R and server.R. Run the application with the button Run App. Change the title of the application. You can call it My first application. Update the application and check that the new title appears. 4.2 Input - output We keep the same application, we don’t care about the structure (rows, columns, tabs…) for the moment. We just want to add: new inputs in sidebarPanel, after the sliderInput. Don’t forget to add commas to separate the inputs; new outputs in mainPanel, after the plotOutput. Don’t forget to add commas to separate the outputs. To summarize, we want one column for all the inputs and another one for all the outputs. Add in ui.R an input which allows to change the color of the histogram. You can use this command: selectInput(inputId = &quot;color&quot;, label = &quot;Couleur :&quot;, choices = c(&quot;Rouge&quot; = &quot;red&quot;, &quot;Vert&quot; = &quot;green&quot;, &quot;Bleu&quot; = &quot;blue&quot;)) Add a new output to visualize the summary of the dataset faithful. You can use: # ui.R verbatimTextOutput(&quot;...&quot;) # server.R output$... &lt;- renderPrint({ summary(...) }) Exercise 4.1 (Adding some inputs/outputs) Add some inputs and outputs on the previous application to propose to the user to change the title of the histogram (use a textInput in the ui and the option main in the hist function); select the variable of faithful for the histogram (use a radioButtons with choices colnames(faithful)); visualize the whole dataset faithful (renderDataTable &amp; dataTableOutput); add a text under the histogram which indicates the number of class (use renderText and paste functions in server, textOutput in ui). replace the selectInput of the color choice by a colourInput (use colourpicker package); export the graph (downloadButton &amp; jpeg). The final application may look like https://input-output-rouviere-shiny.apps.math.cnrs.fr. 4.3 Organizing the application Exercise 4.2 (Structure of an application) Consider the application app_structure available here. It is quite the same as the previous one with a navbarPage which defines a tab Data to visualize the data (table + summary) a tab Visualisation : inputs + histogram. Tab Data: use navlistPanel to separate the summary and the table into two tabs: # rappel de la structure (ui.R) navlistPanel( &quot;Title of the structure&quot;, tabPanel(&quot;Title of the tab&quot;, ... &quot;(content of the tab)&quot;), tabPanel(&quot;Title of the tab&quot;, ... &quot;(content of the tab)&quot;) ) Tab Visualization: change sidebarLayout - sidebarPanel - mainPanel by a fluidRow with 2 columns: 1/4: for the sidebarPanel 3/4: for the mainPanel. fluidRow( column(width = 3, ...), # column 1/4 (3/12) column(width = 9, ...) # column 3/4 (9/12) ) Hint: use wellPanel for the left column. Add a boxplot in the visualisation tab (same variable and same color). You can also use tabsetPanel to obtain two different tabs for the histogram and the boxplot. # rappel de la structure (ui.R) tabsetPanel( tabPanel(&quot;Title of the tab&quot;, ... &quot;(content of the tab)&quot;), tabPanel(&quot;Title of the tab&quot;, ... &quot;(content of the tab)&quot;) ) The final application may look libe https://structure-rouviere-shiny.apps.math.cnrs.fr. Taking things further: use shinydashboard (https://rstudio.github.io/shinydashboard/) for building the same application. 4.4 Adding interactive charts In the previous application, replace histogram and boxplots by javascript charts obtained with rAmCharts. You can use (see https://interactifs-rouviere-shiny-2.apps.math.cnrs.fr) # server.R output$distPlot &lt;- renderAmCharts({...}) # ui.R amChartsOutput(&quot;...&quot;) 4.5 Reactive, isolation, observe, html, … Keep the previous application and add actionButton combined with isolate to update the application only when we click on a button. Use observeEvent to force the visualization of the histogram when we update the application. You can use # think to add &quot;session&quot; shinyServer(function(input, output, session) # an id tabsetPanel(id = &quot;viz&quot;, tabPanel(&quot;Histogram&quot;, ... # and finaly observeEvent(input$go, { updateTabsetPanel(session, inputId = &quot;viz&quot;, selected = &quot;Histogram&quot;) }) Use reactive function to store the selected variable # Example of reactive data &lt;- reactive({ ... }) output$plot &lt;- renderPlot({ x &lt;- data() ... }) Add a title on the dataset with blue color. You can use h1 function: h1(&quot;Dataset&quot;, style = &quot;color : #0099ff;text-align:center&quot;) Add a third tab where you present a summary of your school. You can also add an image and a link to a website (see https://plus-loin-rouviere-shiny-2.apps.math.cnrs.fr). Taking things further: change the theme of the application with a .css file. You can use bootswatch for instance http://bootswatch.com/3. 4.6 Some additional exercises Exercise 4.3 (Descriptive statistics) We consider the dataset SAheart from the bestglm package. Use rAmCharts to visualize histograms of the numeric variables of the dataset and boxplots in terms of the variable chd. Create a shiny web application (you can use shinydashboard) which allows to select one variable among the numeric variables of the dataset. You can use radioButtons with choices=names(SAheart)[sapply(SAheart,class)==&quot;numeric&quot;] visualize the histogram and the boxplot (in terms of chd) of the selected variable. These graphsshould be done with rAmCharts (use amChartsOutput). The required application may look like It is also available at https://lrouviere.shinyapps.io/DESC_APP. Exercise 4.4 (Bike stations in Rennes) Create an application which allows to visualize bike stations in Rennes. It may look like It is also available at https://lrouviere.shinyapps.io/velib/. You can obtain the data on the Rennes métropole website: https://data.rennesmetropole.fr/explore/dataset/etat-des-stations-le-velo-star-en-temps-reel/export/ "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
